---
id: es6-class-mocks
title: ES6 Class Mocks
---

Outline
=========

1. ES6 classes are functions. Techniques described here apply equally to all constructor functions.
1. Can mock with a function or an actual class
1. Mocking with an ES6 class or a vanilla function allows injection but doesn't allow tracking of calls
1. Mocking with `jest.mock('./my-module', () => jest.fn())` allows tracking of calls to constructor.
1. Automocking with `jest.mock('./my-module', () => jest.genMockFromModule('./my-module'))` also allows spying on calls to the constructor, and additionally causes methods to be defined inside instance objects, so calls to methods won't throw errors. Neither allows spying on method calls.
1. Mocking with `jest.fn().mockImplementation()` allows tracking of calls plus injection
1. Since each call to `new` generates a new object, can't set methods to `jest.fn()`. Instead have to save a reference to a jest mock function and set methods to that reference mock.
1. Call `YourClass.mockClear()` and `mockedMethodReference.mockClear()` between tests to reset the calls list.

Questions:

1. What about mock.instances? -- Only returns instances of the mock itself. We need the return values from calls to the mock rather than instances of the mock.
2. What about automocking? - Automocking using [`jest.genMockFromModule`](JestObjectAPI.md#jestgenmockfrommodulemodulename) works for spying on the constructor and ensuring that methods exist, though they will all return `undefined`. Does not allow a way to check for calls to methods; the automock is a prototype function and JS doesn't provide a way to modify it that would allow us to spy on its internal methods. So we have to specify the entire mock ourselves.

# Mocking ES6 Classes

ES6 classes are functions with some syntactic sugar. So any mock for an ES6 class must be a function or an actual ES6 class.

In the Jest framework, there are general approaches to mocking an import using `jest.mock()`.

1. Using a [manual mock](ManualMocks.md) that is implemented in the `__mocks__` folder.
2. Using an automatic mock and setting its implementation by calling [mockImplementation]().
3. Passing a factory function ("module factory") as the [second parameter to `jest.mock()`](JestObjectAPI.md#jestmockmodulename-factory-options), where the factory function returns the mock.


So we mock them using [mock functions](MockFunctions.md).

You can mock ES6 classes using `mockImplementation`.

## Topics

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

## Overview

Therefore the ?? factory function ??passed to `jest.mock()` must return a function; in other words, it must be a higher-order function. -- Make this apply to all cases


## Strategies
There are three ways to inject the mock into a test:
1. [Manual mock](ManualMocks.md) using the `__mocks__` folder
2. Auto-mock using [`jest.mock()` with a second argument ("module factory")](JestObjectAPI.md#jestmockmodulename-factory-options)
3. Auto-mock without the factory parameter

All three use `mockImplementation()` to create a mock function that we can spy on, call `new` on, and that returns an object which mocks an instance object of the mocked class.

## Factory function must return a function


### Simple mock you can call `new` on:
Here's a simple version that, because it returns a function, will allow calling `new`:

    jest.mock('./sound-player', () => {
      return function() {
        return { playSoundFile: () => {} };
      };
    });

***Note: Arrow functions won't work***

Note that our mock can't be an arrow function because we can't call new on an arrow function in Javascript; that's inherent in the language. So this won't work:

    jest.mock('./sound-player', () => {
      return () => { // Does not work; arrow functions can't be called with new
        return { playSoundFile: () => {} };
      };
    });


This will throw ***TypeError: _soundPlayer2.default is not a constructor***.

## Keeping track of usage (spying on the mock)
Not throwing errors is all well and good, but we may need to test whether our constructor was called with the correct parameters.

In order to track calls to the constructor, we can replace the function returned by the HOF with a Jest mock function. We create it with [`jest.fn()`][3], and then we specify its implementation with [`mockImplementation()`][3].

    jest.mock('./sound-player', () => {
      return jest.fn().mockImplementation(() => { // Works and lets you check for constructor calls
        return { playSoundFile: () => {} };
      });
    });

This will let us inspect usage of our mocked class, using `SoundPlayer.mock.calls`.

### Spying on methods of our class
Our mocked class will need to provide any member functions (`playSoundFile` in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.

Because a new mock object will be created during our tests, `SoundPlayer.playSoundFile.calls` won't help us. To work around this, we populate `playSoundFile` with another mock function, and store a reference to that same mock function in our test file, so we can access it during tests.

    let mockPlaySoundFile = jest.fn();
    jest.mock('./sound-player', () => {
      return jest.fn().mockImplementation(() => { // Works and lets you check for constructor calls
        return { playSoundFile: mockPlaySoundFile }; // Now we can track calls to playSoundFile
      });
    });

## Complete example
Here's how it looks in the test file:

```javascript
// sound-player-consumer.test.js
import SoundPlayerConsumer from './sound-player-consumer';
import SoundPlayer from './sound-player';

let mockPlaySoundFile = jest.fn();
jest.mock('./sound-player', () => {
  return jest.fn().mockImplementation(() => {
    return { playSoundFile: mockPlaySoundFile };
  });
});

it('The consumer should be able to call new() on SoundPlayer', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(soundPlayerConsumer).toBeTruthy(); // Constructor ran with no errors
});

it('We can check if the consumer called the class constructor', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(SoundPlayer).toHaveBeenCalled();
});

it('We can check if the consumer called a method on the class instance', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  const coolSoundFileName = 'song.mp3';
  soundPlayerConsumer.playSomethingCool();
  expect(mockPlaySoundFile.mock.calls[0][0]).toEqual(coolSoundFileName);
});

```

  [1]: https://github.com/facebook/jest/issues/5023
  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
  [3]: https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockimplementationfn

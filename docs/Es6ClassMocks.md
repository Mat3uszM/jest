---
id: es6-class-mocks
title: ES6 Class Mocks
---

Outline
=========

1. ES6 classes are functions. Techniques described here apply equally to all constructor functions.
1. Can mock with a function or an actual class
1. Mocking with an ES6 class or a vanilla function allows injection but doesn't allow tracking of calls
1. Mocking with `jest.mock('./my-module', () => jest.fn())` allows tracking of calls to constructor.
1. Automocking with `jest.mock('./my-module', () => jest.genMockFromModule('./my-module'))` also allows spying on calls to the constructor, and additionally causes methods to be defined inside instance objects, so calls to methods won't throw errors. Neither allows spying on method calls.
1. Mocking with `jest.fn().mockImplementation()` allows tracking of calls plus injection
1. Since each call to `new` generates a new object, can't set methods to `jest.fn()`. Instead have to save a reference to a jest mock function and set methods to that reference mock.
1. Call `YourClass.mockClear()` and `mockedMethodReference.mockClear()` between tests to reset the calls list.

Questions:

1. What about mock.instances? -- Only returns instances of the mock itself. We need the return values from calls to the mock rather than instances of the mock.
2. What about automocking? - Automocking using [`jest.genMockFromModule`](JestObjectAPI.md#jestgenmockfrommodulemodulename) works for spying on the constructor and ensuring that methods exist, though they will all return `undefined`. Does not allow a way to check for calls to methods; the automock is a prototype function and JS doesn't provide a way to modify it that would allow us to spy on its internal methods. So we have to specify the entire mock ourselves.

## Topics

<AUTOGENERATED_TABLE_OF_CONTENTS>

---

# Mocking ES6 Classes

ES6 classes are constructor functions with some syntactic sugar. So any mock for an ES6 class must be a function or an actual ES6 class. So we mock them using [mock functions](MockFunctions.md).

In the Jest framework, there are three general approaches to mocking an import using `jest.mock()`.

1. Using a [manual mock](ManualMocks.md) that is implemented in the `__mocks__` folder.
2. Using an automatic mock and setting its implementation by calling [`mockImplementation()`](MockFunctionAPI.md#mockfnmockimplementationfn).
3. Passing a factory function ("module factory") as the [second parameter to `jest.mock()`](JestObjectAPI.md#jestmockmodulename-factory-options), where the factory function returns the mock.

All three use `mockImplementation()` to create a mock function that we can spy on, call `new` on, and that returns an object which mocks an instance object of the mocked class.


## Module factory function must return a function
`mockImplementation(moduleFactory)` and `jest.mock(path, moduleFactory)` expect a **module factory** argument. A module factory is a function that returns the mock.

When we mock a constructor function, the module factory will return a constructor function. In other words, it's a function that returns a function - a higher-order function (HOF).

## Background
Using `jest.fn().mockImplementation()` can make it harder to read what the code is doing. Creating our own mocks can help us understand the process.

### Manual mock that is another ES6 class
If we define an ES6 class using the same filename as the mocked class in the __mocks__ folder, it will serve as the mock. This class will be used in place of the real class. This allows you to inject a test implementation for the class, but does not provide a way to spy on calls.

### Simple mock you can call `new` on:
The module factory function passed to `jest.mock(path, moduleFactory)` or `mockImplementation()` can be a HOF that returns a function. This will allow calling `new` on the mock. Again, this allows us to inject different behavior for testing, but does not provide a way to spy on calls.

```javascript
jest.mock('./sound-player', () => {
  return function() {
    return { playSoundFile: () => {} };
  };
});
```

***Note: Arrow functions won't work***

Note that our mock can't be an arrow function because we can't call new on an arrow function in Javascript; that's inherent in the language. So this won't work:

```javascript
jest.mock('./sound-player', () => {
  return () => { // Does not work; arrow functions can't be called with new
    return { playSoundFile: () => {} };
  };
});
```

This will throw ***TypeError: _soundPlayer2.default is not a constructor***, unless the code is transpiled to ES5.

## Keeping track of usage (spying on the mock)
Injecting a test implementation is helpful, but we may also want to test whether our constructor was called with the correct parameters.

In order to track calls to the constructor, we can replace the function returned by the HOF with a Jest mock function. We create it with [`jest.fn()`](JestObjectAPI.md#jestfnimplementation), and then we specify its implementation with `mockImplementation()`.

```javascript
jest.mock('./sound-player', () => {
  return jest.fn().mockImplementation(() => { // Works and lets you check for constructor calls
    return { playSoundFile: () => {} };
  });
});
```

This will let us inspect usage of our mocked class, using `SoundPlayer.mock.calls`.

### Spying on methods of our class
Our mocked class will need to provide any member functions (`playSoundFile` in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.

A new object will be created each time our mock constructor function is called during our tests. To spy on method calls in all of these objects, we populate `playSoundFile` with another mock function, and store a reference to that same mock function in our test file, so we can access it during tests.

```javascript
let mockPlaySoundFile = jest.fn();
jest.mock('./sound-player', () => {
  return jest.fn().mockImplementation(() => { // Works and lets you check for constructor calls
    return { playSoundFile: mockPlaySoundFile }; // Now we can track calls to playSoundFile
  });
});
```

### Cleaning up between tests
To clear the record of calls to the mock constructor function and its methods, we call [`mockClear()`](MockFunctionAPI.md#mockfnmockclear) in the `beforeEach()` function:

```javascript
beforeEach(() => {
  SoundPlayer.mockClear();
  mockPlaySoundFile.mockClear();
});
```

## Complete example
Here's how it looks in the test file:

```javascript
// sound-player-consumer.test.js
import SoundPlayerConsumer from './sound-player-consumer';
import SoundPlayer from './sound-player';

let mockPlaySoundFile = jest.fn();
jest.mock('./sound-player', () => {
  return jest.fn().mockImplementation(() => {
    return { playSoundFile: mockPlaySoundFile };
  });
});

beforeEach(() => {
  SoundPlayer.mockClear();
  mockPlaySoundFile.mockClear();
});

it('The consumer should be able to call new() on SoundPlayer', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(soundPlayerConsumer).toBeTruthy(); // Constructor ran with no errors
});

it('We can check if the consumer called the class constructor', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(SoundPlayer).toHaveBeenCalledTimes(1);
});

it('We can check if the consumer called a method on the class instance', () => {
  const soundPlayerConsumer = new SoundPlayerConsumer();
  const coolSoundFileName = 'song.mp3';
  soundPlayerConsumer.playSomethingCool();
  expect(mockPlaySoundFile.mock.calls[0][0]).toEqual(coolSoundFileName);
});

```
